# Create a new directory and enter it
function mkd() {
    mkdir -p "$@" && cd "$_"
}

# `up` is a convenient way to navigate back up a file tree, and is a general-use
# replacement for `cd ..`.
# if no arguments are passed, up is simply an alias for `cd ..`.
# with any integer argument n, `cd ..` will be performed n times
function up() {
    # number of times to move up in the directory tree
    TIMES=$1

    if [ -z ${TIMES} ]; then
        TIMES=1
    fi
    while [ ${TIMES} -gt 0 ]; do
        cd ..
        TIMES=$((${TIMES} - 1))
    done
}

# mesure execution time
function exectime() {
  start_time=`date +%s`

  eval '$@'
  hr
  echo ${yellow}run time is $(expr `date +%s` - $start_time)s${reset}
  hr
}

# Get random string from file
function rndstr(){
  local count=$2
  : ${count:=-1}
  f=$1; n=$(expr $RANDOM \* `cat $f | wc -l` \/ 32768 + 1); head -n $n $f | tail $count
}

# Change git origin and add upstream
function gitor() {
    local url=$1

    if [ -d .git ]; then
      if [[ $url != http* && $url != git@* && ! -z "$url" ]]; then
          local url="https://github.com/$1.git"
      fi

      if ! git remote | grep upstream > /dev/null; then
          git remote rename origin upstream
          git remote add origin $url
      fi

      git remote -v
    else
      echo "-=-=-=->> There isn't a git repo! <<-=-=-=-"
    fi;
}

function gitores() {
    if [ -d .git ]; then
      if git remote | grep upstream > /dev/null; then
          git remote rm origin
          git remote rename upstream origin
      fi

      git remote -v
    else
      echo "-=-=-=->> There isn't a git repo! <<-=-=-=-"
    fi;
}

# Start an HTTP server from a directory, optionally specifying the port
function server() {
    local port="${1:-8000}"
    sleep 1 && open "http://localhost:${port}/" &
    # Set the default Content-Type to `text/plain` instead of `application/octet-stream`
    # And serve everything as UTF-8 (although not technically correct, this doesnâ€™t break anything for binary files)
    python -c $'import SimpleHTTPServer;\nmap = SimpleHTTPServer.SimpleHTTPRequestHandler.extensions_map;\nmap[""] = "text/plain";\nfor key, value in map.items():\n\tmap[key] = value + ";charset=UTF-8";\nSimpleHTTPServer.test();' "$port"
}

# If given two arguments to cd, replace the first with the second in $PWD,
# emulating a Zsh function that I often find useful; preserves options too
cd() {
    local arg
    local -a opts
    for arg in "$@" ; do
        case $arg in
            --)
                shift
                break
                ;;
            -*)
                shift
                opts=("${opts[@]}" "$arg")
                ;;
            *)
                break
                ;;
        esac
    done
    if (($# == 2)) ; then
        if [[ $PWD == *"$1"* ]] ; then
            builtin cd "${opts[@]}" -- "${PWD/$1/$2}"
        else
            printf 'bash: %s: could not replace substring\n' \
                "$FUNCNAME" >&2
            return 2
        fi
    else
        builtin cd "${opts[@]}" -- "$@"
    fi
}

# Count files
cf() {
    local dir

    # Specify directory to check
    dir=${1:-$PWD}

    # Error conditions
    if [[ ! -e $dir ]] ; then
        printf 'bash: %s: %s does not exist\n' \
            "$FUNCNAME" "$dir" >&2
        return 1
    elif [[ ! -d $dir ]] ; then
        printf 'bash: %s: %s is not a directory\n' \
            "$FUNCNAME" "$dir" >&2
        return 1
    elif [[ ! -r $dir ]] ; then
        printf 'bash: %s: %s is not readable\n' \
            "$FUNCNAME" "$dir" >&2
        return 1
    fi

    # Count files and print; use a subshell so options are unaffected
    (
        shopt -s dotglob nullglob
        declare -a files=("$dir"/*)
        printf '%d\t%s\n' "${#files[@]}" "$dir"
    )
}

# Compare original and gzipped file size
function gz() {
    local origsize=$(wc -c < "$1")
    local gzipsize=$(gzip -c "$1" | wc -c)
    local ratio=$(echo "$gzipsize * 100/ $origsize" | bc -l)
    printf "orig: %d bytes\n" "$origsize"
    printf "gzip: %d bytes (%2.2f%%)\n" "$gzipsize" "$ratio"
}

# `s` with no arguments opens the current directory in Sublime Text, otherwise
# opens the given location
function s() {
    if [ $# -eq 0 ]; then
        subl -a .
    else
        subl -a "$@"
    fi
}

# `a` with no arguments opens the current directory in Atom Editor, otherwise
# opens the given location
function a() {
    if [ $# -eq 0 ]; then
        atom .
    else
        atom "$@"
    fi
}

# `o` with no arguments opens current directory, otherwise opens the given
# location
function o() {
    if [ $# -eq 0 ]; then
        open .
    else
        open "$@"
    fi
}

# sanitize filename: lowercase, no other characters than letters, digits, dash, underscore and dot
function sanitize() {
    for file in *; do
       file_clean=`echo $file | tr '[:upper:]' '[:lower:]' | tr -cd "[:alnum:]-_."`
       if [ "${file}" != "${file_clean}" ]; then
           echo "$file > $file_clean"
           mv "$file" "$file_clean"
       fi
    done
}

# GitHub URL for current repo.
function ghurl() {
  local remotename="${@:-origin}"
  local remote="$(git remote -v | awk '/^'"$remotename"'.*\(push\)$/ {print $2}')"
  [[ "$remote" ]] || return
  local user_repo="$(echo "$remote" | perl -pe 's/.*:\/\///;s/\.git$//;s/git@//;s/\:/\//')"
  echo "https://$user_repo"
}

# NPM URL for current package.
function npmurl() {
  local package=`jsonval package.json name | tr -d ' '`
  [[ "$package" ]] || return
  echo "https://npmjs.com/package/$package"
}

# Quickly get image dimensions from the command line
function imgsize() {
  local width height
  if [[ -f $1 ]]; then
    height=$(sips -g pixelHeight "$1"|tail -n 1|awk '{print $2}')
    width=$(sips -g pixelWidth "$1"|tail -n 1|awk '{print $2}')
    echo "${width} x ${height}"
  else
    echo "File not found"
  fi
}

# SSHFS mount
function sshfsmount() {
  local mountPath="/Volumes/sshfs"

  mkdir -p $mountPath

  sshfs -o Ciphers=arcfour -o Compression=yes -o auto_cache,reconnect,defer_permissions,noappledouble -o workaround=nodelaysrv -o cache_stat_timeout=600 -o IdentityFile=~/.ssh/id_rsa $1 $mountPath
}

# Grep with file mask filter
function fgr() {
  find -name $2 -type f | xargs grep $1
}

function upsearch () {
  slashes=${PWD//[^\/]/}
  directory="$PWD"
  for (( n=${#slashes}; n>0; --n ))
  do
    test -e "$directory/$1" && echo "$directory/$1" && return
    directory="$directory/.."
  done
}

# Print all 256 colors
function aa_256()
{
  ( x=`tput op` y=`printf %$((${COLUMNS}-6))s`;
  for i in {0..256};
  do
  o=00$i;
  echo -e ${o:${#o}-3:3} `tput setaf $i;tput setab $i`${y// /=}$x;
  done )
}

# get value of property from json file
function jsonval() {
  KEY=$2
  num=$3
  cat $1 | awk -F"[,:}]" '{for(i=1;i<=NF;i++){if($i~/\042'$KEY'\042/){print $(i+1)}}}' | tr -d '"' | sed -n ${num}p
}

# Create a data URL from a file
function dataurl() {
  local mimeType=$(file -b --mime-type "$1")
  if [[ $mimeType == text/* ]]; then
    mimeType="${mimeType};charset=utf-8"
  fi
  echo "data:${mimeType};base64,$(openssl base64 -in "$1" | tr -d '\n')"
}
